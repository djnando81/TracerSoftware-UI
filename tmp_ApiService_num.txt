001: 
002: package com.tracersoftware.apiinfo;
003: 
004: import com.tracersoftware.common.SessionManager;
005: import com.fasterxml.jackson.databind.JsonNode;
006: import com.fasterxml.jackson.databind.ObjectMapper;
007: import java.io.IOException;
008: import java.net.HttpURLConnection;
009: import java.net.URL;
010: 
011: public class ApiService {
012:     private String urlBase;
013:     private String authToken; // Token JWT o similar
014:     private String lastLoginResponseJson;
015:     private final ObjectMapper mapper = new ObjectMapper();
016: 
017:     public ApiService(String urlBase) {
018:         this.urlBase = urlBase;
019:     }
020: 
021:     public boolean pingApi() {
022:         try {
023:             URL url = new URL(normalize(urlBase) + "/api/apiinfo/health");
024:             HttpURLConnection conn = (HttpURLConnection) url.openConnection();
025:             conn.setRequestMethod("GET");
026:             conn.setConnectTimeout(3000);
027:             // Si hay token, agregarlo
028:             String token = SessionManager.getAuthToken();
029:             if (token != null && !token.isEmpty()) {
030:                 conn.setRequestProperty("Authorization", "Bearer " + token);
031:             }
032:             conn.connect();
033:             int code = conn.getResponseCode();
034:             return code == 200;
035:         } catch (IOException e) {
036:             return false;
037:         }
038:     }
039: 
040:     /**
041:      * Realiza login contra la API. Si es exitoso, guarda el token para futuras llamadas.
042:      * @param username nombre de usuario
043:      * @param password contraseña
044:      * @return true si login exitoso, false si no
045:      */
046:     public boolean login(String username, String password) {
047:         try {
048:             // Usar estrictamente la base del config (inyectada al construir ApiService)
049:             String base = normalize(this.urlBase);
050:             return doLoginAgainst(base, username, password);
051:         } catch (Exception ex) {
052:             return false;
053:         }
054:     }
055: 
056:     private boolean doLoginAgainst(String base, String username, String password) throws IOException {
057:         // endpoint de login configurable (default: /api/auth/login)
058:         String configured = null;
059:         try { configured = com.tracersoftware.common.ConfigManager.get("api.loginEndpoint"); } catch (Exception ignored) {}
060:         String[] endpoints = (configured != null && !configured.isBlank())
061:                 ? new String[] { configured.trim() }
062:                 : new String[] { "/api/auth/login" };
063:         IOException lastEx = null;
064:         for (String ep : endpoints) {
065:             URL url = new URL(base + ep);
066:             HttpURLConnection conn = (HttpURLConnection) url.openConnection();
067:             // If HTTPS, install permissive trust manager for dev environments
068:             if (conn instanceof javax.net.ssl.HttpsURLConnection https) {
069:                 try {
070:                     javax.net.ssl.TrustManager[] trustAll = new javax.net.ssl.TrustManager[]{ new javax.net.ssl.X509TrustManager() {
071:                     public java.security.cert.X509Certificate[] getAcceptedIssuers(){return new java.security.cert.X509Certificate[0];}
072:                     public void checkClientTrusted(java.security.cert.X509Certificate[] c,String a){}
073:                     public void checkServerTrusted(java.security.cert.X509Certificate[] c,String a){}
074:                 }};
075:                 javax.net.ssl.SSLContext sc = javax.net.ssl.SSLContext.getInstance("TLS");
076:                 sc.init(null, trustAll, new java.security.SecureRandom());
077:                 https.setSSLSocketFactory(sc.getSocketFactory());
078:                 https.setHostnameVerifier((h, s) -> true);
079:             } catch (Exception ignored) {}
080:         }
081:             conn.setRequestMethod("POST");
082:             conn.setRequestProperty("Content-Type", "application/json");
083:             conn.setRequestProperty("Accept", "application/json");
084:             conn.setConnectTimeout(6000);
085:             conn.setReadTimeout(10000);
086:             conn.setDoOutput(true);
087:             // Build a tolerant payload: include variations so model binding succeeds
088:             com.fasterxml.jackson.databind.node.ObjectNode obj = mapper.createObjectNode();
089:             obj.put("Nombre", username);
090:             obj.put("nombre", username);
091:             if (username != null && username.contains("@")) {
092:                 obj.put("Email", username);
093:                 obj.put("email", username);
094:             }
095:             obj.put("Password", password);
096:             obj.put("password", password);
097:         // Enviar exactamente el DTO documentado: { "Nombre", "Password" }
098:         String json = obj.toString();
099:             try (java.io.OutputStream os = conn.getOutputStream()) {
100:                 byte[] input = json.getBytes(java.nio.charset.StandardCharsets.UTF_8);
101:                 os.write(input, 0, input.length);
102:             }
103:             int code = conn.getResponseCode();
104:             // Debug log
105:             try {
106:                 java.nio.file.Path dbgReq = java.nio.file.Paths.get("debug_auth.log");
107:                 String reqLine = java.time.ZonedDateTime.now().toString() + " | LOGIN POST " + url.toString() + " | Payload: " + json + " | Code: " + code + System.lineSeparator();
108:                 java.nio.file.Files.write(dbgReq, reqLine.getBytes(java.nio.charset.StandardCharsets.UTF_8), java.nio.file.StandardOpenOption.CREATE, java.nio.file.StandardOpenOption.APPEND);
109:             } catch (Exception ignored) {}
110:             if (code == 200 || code == 201) {
111:                 try (java.io.InputStream is = conn.getInputStream()) {
112:                     String response = new String(is.readAllBytes(), java.nio.charset.StandardCharsets.UTF_8);
113:                     this.lastLoginResponseJson = response;
114:                     try {
115:                         JsonNode root = mapper.readTree(response);
116:                         String token = null;
117:                         if (root.has("accessToken")) token = root.path("accessToken").asText(null);
118:                         if (token == null && root.has("token")) token = root.path("token").asText(null);
119:                         if (token == null && root.has("access_token")) token = root.path("access_token").asText(null);
120:                         // Also accept nested: { data: { accessToken: ... } }
121:                         if (token == null && root.has("data") && root.path("data").isObject()) {
122:                             JsonNode data = root.path("data");
123:                             if (data.has("accessToken")) token = data.path("accessToken").asText(null);
124:                             if (token == null && data.has("token")) token = data.path("token").asText(null);
125:                         }
126:                         if (token != null && !token.isBlank()) {
127:                             this.authToken = token.trim().replaceFirst("(?i)^Bearer\\s+", "");
128:                             SessionManager.setAuthToken(this.authToken);
129:                             try { com.tracersoftware.auth.SessionManager.get().setSession(this.authToken, null, username, new String[0], null); } catch (Exception ignored) {}
130:                             return true;
131:                         }
132:                     } catch (Exception ex) {
133:                         String token = extractTokenFromJson(response);
134:                         if (token != null) {
135:                             this.authToken = token;
136:                             SessionManager.setAuthToken(token);
137:                             try { com.tracersoftware.auth.SessionManager.get().setSession(token, null, username, new String[0], null); } catch (Exception ignored) {}
138:                             return true;
139:                         }
140:                     }
141:                 }
142:             } else {
143:                 try {
144:                     java.io.InputStream es = conn.getErrorStream();
145:                     String errBody = es != null ? new String(es.readAllBytes(), java.nio.charset.StandardCharsets.UTF_8) : "";
146:                     this.lastLoginResponseJson = errBody;
147:                 } catch (Exception ignored) {}
148:             }
149:             // if we reached here and not returned true, fallthrough to next endpoint
150:         }
151:         return false;
152:     }
153: 
154:     // Fallbacks eliminados: se usa la URL de config.ini
155: 
156:     private String normalize(String base) {
157:         if (base == null) return "";
158:         String b = base.trim();
159:         if (b.endsWith("/")) b = b.substring(0, b.length()-1);
160:         return b;
161:     }
162: 
163:     public String getLastLoginResponseJson() { return lastLoginResponseJson; }
164: 
165:     private String extractTokenFromJson(String json) {
166:         // Busca accessToken primero, luego token
167:         String[] keys = {"accessToken", "token"};
168:         for (String key : keys) {
169:             int idx = json.indexOf('"' + key + '"');
170:             if (idx == -1) continue;
171:             int start = json.indexOf(':', idx);
172:             int quote1 = json.indexOf('"', start);
173:             int quote2 = json.indexOf('"', quote1 + 1);
174:             if (quote1 != -1 && quote2 != -1) {
175:                 return json.substring(quote1 + 1, quote2);
176:             }
177:         }
178:         return null;
179:     }
180: 
181:     public String getAuthToken() {
182:         return authToken;
183:     }
184:     
185:     /**
186:      * Solicita al backend la creación de una API key para el usuario autenticado.
187:      * Si el backend no soporta esta operación, devuelve null.
188:      */
189:     public String createApiKey() {
190:         try {
191:             URL url = new URL(urlBase + "/api/auth/apikey");
192:             HttpURLConnection conn = (HttpURLConnection) url.openConnection();
193:             conn.setRequestMethod("POST");
194:             conn.setRequestProperty("Content-Type", "application/json");
195:             conn.setConnectTimeout(5000);
196:             conn.setDoOutput(true);
197:             String token = SessionManager.getAuthToken();
198:             if (token != null && !token.isEmpty()) {
199:                 conn.setRequestProperty("Authorization", "Bearer " + token);
200:             }
201:             try (java.io.OutputStream os = conn.getOutputStream()) {
202:                 byte[] input = "{}".getBytes(java.nio.charset.StandardCharsets.UTF_8);
203:                 os.write(input, 0, input.length);
204:             }
205:             int code = conn.getResponseCode();
206:             if (code >= 200 && code < 300) {
207:                 try (java.io.InputStream is = conn.getInputStream()) {
208:                     String response = new String(is.readAllBytes(), java.nio.charset.StandardCharsets.UTF_8);
209:                     String key = extractTokenFromJson(response);
210:                     return key;
211:                 }
212:             }
213:         } catch (IOException e) {
214:             // ignore and return null
215:         }
216:         return null;
217:     }
218:     // Métodos futuros: para cada request protegida, usar el token de SessionManager
219: }
